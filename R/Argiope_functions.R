#https://r-spatial.org/r/2023/05/15/evolution4.html
#library(raster)
#library(ijtiff)
#library(chron)
#library(leaflet)
#library(leaflet.extras)
#library(mapview)
#library(mapedit)
#library(leafem)
#library(velox)
#library(tcltk)
#library(shiny)

#' Find grey values coordinates interactively
#'
#' Find grey values coordinates interactively. This function is used internally.
#'
#' @param img A tiff image generated by dcraw.
#' @param crop crop percentage to reduce image size at each side. e.g. crop = c(10,10,10,10).
#' @param N Number of points.
#' @export
get_scale_interactive<-function(img,
                                crop,
                                N) {

  #file.name<-"P1040507.RW2"
  #tags<-dcraw.tags(file.name[[1]])
  #img.size<-as.numeric(strsplit(x=tags$`Output size`, split=" x ")[[1]])
  #options(fftempdir = tempdir())
  #img<-ff::ff(as.vector(read.dcraw(file=file.name[[1]])),
  #            dim=c(img.size[[2]],img.size[[1]],3,1))

  #tags<-dcraw.tags(img)
  #img.size<-as.numeric(strsplit(x=tags$`Output size`, split=" x ")[[1]])
  #options(fftempdir = tempdir())



  #Rsmall<-velox::velox(terra::rast(img[,,1,1]))
  #Rsmall$aggregate(factor=5, aggtype='median')
  #Rsmall<-Rsmall$as.RasterLayer(band=1)
  a<-terra::rast(img[,,1,1])
  terra::writeRaster(a, f <- tempfile(fileext='.tif'), datatype='INT2U')
  Rsmall<-gdalUtilities::gdalwarp(f, f2 <- tempfile(fileext='.tif'), r='med',
                                  multi=TRUE, tr=terra::res(a)*5)
  Rsmall<-terra::rast(Rsmall)
  #Gsmall<-velox::velox(terra::rast(img[,,2,1]))
  #Gsmall$aggregate(factor=5, aggtype='median')
  #Gsmall<-Gsmall$as.RasterLayer(band=1)
  a<-terra::rast(img[,,2,1])
  terra::writeRaster(a, f <- tempfile(fileext='.tif'), datatype='INT2U')
  Gsmall<-gdalUtilities::gdalwarp(f, f2 <- tempfile(fileext='.tif'), r='med',
                             multi=TRUE, tr=terra::res(a)*5)
  Gsmall<-terra::rast(Gsmall)

  #Bsmall<-velox::velox(terra::rast(img[,,3,1]))
  #Bsmall$aggregate(factor=5, aggtype='median')
  #Bsmall<-Bsmall$as.RasterLayer(band=1)
  a<-terra::rast(img[,,3,1])
  terra::writeRaster(a, f <- tempfile(fileext='.tif'), datatype='INT2U')
  Bsmall<-gdalUtilities::gdalwarp(f, f2 <- tempfile(fileext='.tif'), r='med',
                                  multi=TRUE, tr=terra::res(a)*5)
  Bsmall<-terra::rast(Bsmall)

  rm(a)

  r  <- terra::rast(xmin=0, xmax=1,
                       ymin=0, ymax=nrow(Rsmall)/ncol(Rsmall),
                       ncols=ncol(Rsmall), nrows=nrow(Rsmall))
  r <- terra::setValues(r, as.vector(Rsmall))
  g <- terra::setValues(r, as.vector(Gsmall))
  b <- terra::setValues(r, as.vector(Bsmall))

  #process image for better display
  #r[r<0]<-0
  #r[r>100]<-100
  #g[g<0]<-0
  #g[g>100]<-100
  #b[b<0]<-0
  #b[b>100]<-100
  r<-sqrt(r)
  g<-sqrt(g)
  b<-sqrt(b)

  rm(img)

  if(any(crop>0)) {

    crop.area<-terra::ext(r)
    crop.area<-crop.area*(1-crop/100)
    r<-terra::crop(x=r, y=crop.area)
    g<-terra::crop(x=g, y=crop.area)
    b<-terra::crop(x=b, y=crop.area)
    rm(crop.area)

  }

  small.image<-c(r,g,b)

  gc(verbose = FALSE, reset = TRUE, full = TRUE)

  #asp=1.3
  dev.new(noRStudioGD = TRUE)
  par(mfrow=c(1,1))
  terra::plotRGB(x=small.image, scale=255)

  #N=5
  print("Click on the image to select points")
  grey<-terra::click(x=small.image,
                      xy=TRUE,
                      n=N, id=FALSE,
                      cell=T, type="p", show=FALSE,
                      col="red",bg="red",cex=2,pch=21)

  return(grey)

}



#Function to extract grey values from the colourchecker
#' Extract grey values
#'
#' Extract grey values from the colourchecker. This function is used internally.
#'
#' @param img The raw version of the 'image.model'. Usually a larger and with different proportions. Those are adjusted internally to proper data extraction. A tiff image generated by dcraw.
#' @param method Whether a UNET has been used to find the colorcheker scale or select scale location interactively.
#' @param model The Keras Unet model used for predictions. Used when method = "AI".
#' @param image.model Array of image to apply the AI model, same size as model training. Usually a 512x512px or 256x256px image.
#' @param colorchecker_x_lim Relative position of the left and rigth vertex of each grey scale value to be extracted. Used when method = "AI".
#' @param colorchecker_y_lim Relative position of the bottom and top vertex of each grey scale value to be extracted. Used when method = "AI".
#' @param colorchecker_y_size The size of the colorchecker rectangle minor side.
#' @param colorchecker_x_size The size of the colorchecker rectangle largest side.
#' @param X The x-axis center point of colorcheker scale squares. Used when method = "interactive".
#' @param Y The y-axis center point of colorcheker scale squares. Used when method = "interactive".
#' @param Size The size, in pixels, of the square to get colorcheker scale values. Used when method = "interactive".
#' @param save Should the colorchecker image be saved?
#' @param filename Name of file to be saved.
#' @return A list containing: 1. Median of R,G, and B scale values; 2. MAD of R,G, and B pixel scale values; and 3. Image scale in pixel/cm2 and pixel/cm. Those are calculated based on the colorchecker size (available when 'method = "AI"' only).
#' @export
get_scale_values<-function(img,
                           method = c("AI","interactive"),
                           model,
                           image.model,
                           colorchecker_x_lim,
                           colorchecker_y_lim,
                           colorchecker_y_size,
                           colorchecker_x_size,
                           X,
                           Y,
                           Size,
                           save=TRUE,
                           filename
) {

  nrow<-attr(attr(img, "virtual"), "Dim")[[1]]
  ncol<-attr(attr(img, "virtual"), "Dim")[[2]]

  if (method == "AI") {

    AI<-colorchecker.scale.data.extraction(
      image.model=image.model,
      image.raw=img,
      model=model,
      save.colorchecker.image = save,
      save.name = filename,
      colorchecker_y_lim = colorchecker_y_lim,
      colorchecker_x_lim = colorchecker_x_lim,
      colorchecker_y_size = colorchecker_y_size,
      colorchecker_x_size = colorchecker_x_size
    )

    AI.df.median<-as.data.frame(AI$colorchecker.median)
    AI.df.mad<-as.data.frame(AI$colorchecker.mad)

    medianR<-as.numeric(AI.df.median[1,])
    medianG<-as.numeric(AI.df.median[2,])
    medianB<-as.numeric(AI.df.median[3,])

    madR<-as.numeric(AI.df.mad[1,])
    madG<-as.numeric(AI.df.mad[2,])
    madB<-as.numeric(AI.df.mad[3,])

    scale_pixels_cm2 <- AI$scale_pixels_cm2
    scale_pixels_cm <- AI$scale_pixels_cm
    Npixels <- AI$Npixels

    scale_pixels_cm.raw <- AI$scale_pixels_cm.raw
    scale_pixels_cm2.raw <- AI$scale_pixels_cm2.raw
    Npixels.raw <- AI$Npixels.raw

    rm(img)

  }

  if (method == "interactive") {

    scale_pixels_cm2 <- NA
    scale_pixels_cm <- NA
    Npixels <- NA

    scale_pixels_cm.raw <- NA
    scale_pixels_cm2.raw <- NA
    Npixels.raw <- NA

    greyR<-list()
    greyG<-list()
    greyB<-list()

    if (Size %% 2 != 0) {Size <- Size+1}

    for (i in 1:length(Y)) {

      greyR[[i]] <- img[(Y[[i]]-Size/2):(Y[[i]]+Size/2), (X[[i]]-Size/2):(X[[i]]+Size/2), 1, 1]
      greyG[[i]] <- img[(Y[[i]]-Size/2):(Y[[i]]+Size/2), (X[[i]]-Size/2):(X[[i]]+Size/2), 2, 1]
      greyB[[i]] <- img[(Y[[i]]-Size/2):(Y[[i]]+Size/2), (X[[i]]-Size/2):(X[[i]]+Size/2), 3, 1]

    }

    #scaleR<-matrix(ncol=Size*length(Y),nrow=Size*length(Y))
    scaleR<-NULL

    for (i in 1:length(greyR)) {

      #fazer uma escala falsa para salvar depois
      #scaleR[(1+(i-1)*(Size)):i*(Size), (1+(i-1)*(Size)):i*(Size)]<-greyR[[i]]
      scaleR<-cbind(scaleR,greyR[[i]])

    }

    medianR<-sapply(greyR, FUN=stats::median)
    medianG<-sapply(greyG, FUN=stats::median)
    medianB<-sapply(greyB, FUN=stats::median)

    madR<-sapply(greyR, FUN=stats::mad)
    madG<-sapply(greyG, FUN=stats::mad)
    madB<-sapply(greyB, FUN=stats::mad)


  }

  if (save==TRUE & method == "interactive") {
    have.dir<-dir.exists("colorchecker")
    if (have.dir==FALSE) {dir.create("colorchecker")}

    jpeg::writeJPEG(image=sqrt(scaleR)/256,
                    target=file.path("colorchecker", paste("colorchecker_",filename,".jpg", sep="")))
  }

  order<-order(medianR, decreasing = TRUE)

  medianR<-medianR[order]
  medianG<-medianG[order]
  medianB<-medianB[order]

  madR<-madR[order]
  madG<-madG[order]
  madB<-madB[order]

  medians<-data.frame(medianR=medianR,medianG=medianG,medianB=medianB)
  mads<-data.frame(madR=madR,madG=madG,madB=madB)

  return(list(median=medians,
              mad=mads,
              scale_pixels_cm2 = scale_pixels_cm2,
              scale_pixels_cm = scale_pixels_cm,
              Npixels = Npixels,
              scale_pixels_cm.raw = scale_pixels_cm.raw,
              scale_pixels_cm2.raw = scale_pixels_cm2.raw,
              Npixels.raw = Npixels.raw
  ))

}





#function to calculate new Rvalues for the image
#based on scale values
#' Extract grey values
#'
#' Calculates new R,G and B reflectance values for the image based on scale values
#'
#' @param scale Scale data from function get_scale_values
#' @param img A tiff image generated by dcraw.
#' @param whichRvalues Which grey values should be used.
#' @param RvaluesR Reflectance values for the R channel.
#' @param RvaluesG Reflectance values for the G channel.
#' @param RvaluesB Reflectance values for the B channel.
#' @param return.image Logical. Should the image be returned?
#' @param save Logical. Should the converted image be saved?
#' @param file.name Image file name.
#' @return A list with: 1. linear models used to convert images; and 2. the converted image.
#' @export
predict_reflect<-function(scale, #scale data from function get_scale_values
                          img, #A tiff image generated by dcraw
                          whichRvalues, #which grey values should be used
                          RvaluesR,
                          RvaluesG,
                          RvaluesB,
                          return.image,
                          save,
                          file.name=NULL) {

  modelR<-stats::lm(RvaluesR[whichRvalues]~medianR,data=scale$median[whichRvalues,])
  modelG<-stats::lm(RvaluesG[whichRvalues]~medianG,data=scale$median[whichRvalues,])
  modelB<-stats::lm(RvaluesB[whichRvalues]~medianB,data=scale$median[whichRvalues,])

  new.image<-ff::ff(0, dim = c(attr(attr(img, "virtual"), "Dim")[[1]],
                               attr(attr(img, "virtual"), "Dim")[[2]],
                              3))

  new.image[,,1]<-predict(object=modelR, newdata=data.frame(medianR=as.vector(img[,,1,1])))
  new.image[,,2]<-predict(object=modelG, newdata=data.frame(medianG=as.vector(img[,,2,1])))
  new.image[,,3]<-predict(object=modelB, newdata=data.frame(medianB=as.vector(img[,,3,1])))

  #newdataR<-data.frame(medianR=as.vector(img[,,1,1]))
  #new.image[,,1]<-predict(object=modelR, newdata=newdataR)

  #newdataG<-data.frame(medianG=as.vector(img[,,2,1]))
  #new.image[,,2]<-predict(object=modelG, newdata=newdataG)

  #newdataB<-data.frame(medianB=as.vector(img[,,3,1]))
  #new.image[,,3]<-predict(object=modelB, newdata=newdataB)

  #rm(newdataR)
  #rm(newdataG)
  #rm(newdataB)
  rm(img)

  models<-list(modelR=list(coefficients=modelR$coefficients,
                           model=modelR$model,
                           R2=summary(modelR)$r.squared),
               modelG=list(coefficients=modelG$coefficients,
                           model=modelG$model,
                           R2=summary(modelG)$r.squared),
               modelB=list(coefficients=modelB$coefficients,
                           model=modelB$model,
                           R2=summary(modelB)$r.squared))
  rm(modelR)
  rm(modelG)
  rm(modelB)

  if(save==TRUE) {
    if (is.null(file.name)==TRUE) {file.name <- "img"}
    ijtiff::write_tif(img=new.image[,,],
              path=paste(file.name,".tiff", sep=""),
              bits_per_sample = "auto",
              compression = "none",
              overwrite = TRUE, msg = TRUE)
    #writeRaster(x=image, filename=paste(file.name,".tif", sep=""), format="GTiff")
  }

  rm(new.image)
  if (return.image==TRUE) {
  return(list(models=models, newimage=new.image))} else
  {return(list(models=models))}

}

#find group of fotos by interval time in seconds
#' Extract dcraw metadata
#'
#' Get camera metadata using dcraw.
#'
#' @param files A vector of image file names.
#' @return A data.frame with metadata.
#' @details This function uses dcraw by Dave Coffin (https://www.dechifro.org/dcraw/). Windows version was compiled by Sergio Namias (http://www.centrostudiprogressofotografico.it/en/dcraw/). This is a 64bit version. It may not work in Windows 32bit OSs.
#' @export
dcraw.tags<-function (files) {

  #files<-"IMG_1826.CR2"
  old<-getwd()

  Argiope.path<-file.path(find.package("Argiope"),"dcraw")
  setwd(file.path(find.package("Argiope")))
  #exif<-system2(command=Argiope.path, args=paste("-i -v", files[[1]]), stdout = TRUE)
  exif<-system2(command="dcraw", args=paste("-i -v", shQuote(file.path(old,files[[1]]))), stdout = TRUE)
  exif.new<-data.frame(matrix(ncol=length(exif),nrow=length(files)))
  for (k in 1:length(files)) {
    #exif<-system2(command=Argiope.path, args=paste("-i -v", files[[k]]), stdout = TRUE)
    exif<-system2(command="dcraw", args=paste("-i -v", shQuote(file.path(old,files[[k]]))), stdout = TRUE)

    for(i in 1:length(exif)) {
      size<-length(unlist(strsplit(exif[[i]],split=": ")))
      if(size>1) {

        exif.new[k,i]<-unlist(strsplit(exif[[i]],split=": "))[[2]]
        names(exif.new)[[i]]<-paste(unlist(strsplit(exif[[i]],split=": "))[[1]])

      }

      if(size==1 & size) {
        exif.new[k,i]<-unlist(strsplit(exif[[i]],split=": "))
      }

      if(size==0 & size) {
      }
    }
  }

  exif.new$Filename<-basename(exif.new$Filename)

  dates<-exif.new$Timestamp
  dates<-strsplit(x=dates, split=" ")
  month<-function(month) {
    #vai errar o dia em ano bissexto
    if (month=="Jan") {number<-0}
    if (month=="Feb") {number<-31}
    if (month=="Mar") {number<-31+28}
    if (month=="Apr") {number<-31+28+31}
    if (month=="May") {number<-31+28+31+30}
    if (month=="Jun") {number<-31+28+31+30+31}
    if (month=="Jul") {number<-31+28+31+30+31+30}
    if (month=="Aug") {number<-31+28+31+30+31+30+31}
    if (month=="Sep") {number<-31+28+31+30+31+30+31+31}
    if (month=="Oct") {number<-31+28+31+30+31+30+31+31+30}
    if (month=="Nov") {number<-31+28+31+30+31+30+31+31+30+31}
    if (month=="Dec") {number<-31+28+31+30+31+30+31+31+30+31+30}
    return(number)
  }

  seconds<-0
  for (i in 1:length(dates)) {
  #as.POSIXcl is not working on PCs. Done by hand:
  seconds[[i]]<-month(dates[[i]][[2]])*24*60*60+
    as.numeric(dates[[i]][[3]])*24*60*60+
    sum(as.numeric(unlist(strsplit(x=dates[[i]][[4]], split=":")))*c(60*60,60,1))+
    (as.numeric(dates[[i]][[5]])-2000)*365*24*60*60
  }

  exif.new$seconds<-seconds

  setwd(old)

  return(exif.new)
}


#find group of fotos by interval time in seconds
#' Find groups
#'
#' Find group of photos based on exif data and photo interval time, in seconds. This function is used internally.
#'
#' @param file.name A vector of image file names.
#' @param interval Interval, in seconds, to group images.
#' @return A data.frame with selected exif metadata and groupings.
#' @export
find_group<-function(file.name, interval = 3) {

  exif<-dcraw.tags(file.name)

  #interval=3
  groups<-exif$seconds
  for (i in 1:length(groups)) {
    groups[groups>= groups[[i]]-interval &
             groups<= groups[[i]]+interval]<-groups[[i]]
  }

  groups<-factor(groups)
  n.groups<-length(levels(groups))
  names.groups<-paste(rep("group",n.groups),seq(1,n.groups),sep="")
  levels(groups)<-paste(names.groups)

  exif$groups<-groups
  return(exif)

}


#' Convert photos
#'
#' Convert photos to standardised R, G and B values based on a known grey scale.
#'
#' @param auto Logical. Should best photos be selected automatically?
#' @param interval Interval, in seconds, to group images. Used when auto=TRUE.
#' @param limit A threshold of maximum grey scale reflectance value by which an image is rejected. Used when auto=TRUE.
#' @param path Path containing RAW images to be analysed.
#' @param ext Raw image extension.
#' @param method Whether a UNET AI has been used to find the colorcheker scale or select colorchecker interactively.
#' @param model The Keras Unet model used for predictions. Used when 'method = AI'.
#' @param path.image.model #Path containing images to be predicted by model, same size as model training. A smaller version of 'img'. Used when 'method = AI'.
#' @param ext.model Unet model image extension. Used when 'method = AI'.
#' @param colorchecker_x_lim Relative position of the left and right vertex of each grey scale value to be extracted. Used when 'method = AI'.
#' @param colorchecker_y_lim Relative position of the bottom and top vertex of each grey scale value to be extracted. Used when 'method = AI'.
#' @param colorchecker_y_size The size of the colorchecker rectangle minor side.
#' @param colorchecker_x_size The size of the colorchecker rectangle largest side.
#' @param crop Crop percentage to reduce image size in each side. e.g. crop = c(10,10,10,10).
#' @param Size The size, in pixels, of the square to get colorcheker scale values. Used when 'method = interactive'.
#' @param RvaluesR Reflectance values for the R channel.
#' @param RvaluesG Reflectance values for the G channel.
#' @param RvaluesB Reflectance values for the B channel.
#' @param whichRvalues Which grey values should be used.
#' @param bug.rotate Should image be rotate in case of low R2?
#' @param save Logical. Should the converted image be saved? Very large TIFF files.
#' @return A list containing: 1. Median of R,G, and B scale values; 2. R,G, and B pixel scale values; and 3. the linear models used to convert images;
#' @details This function uses dcraw by Dave Coffin (https://www.dechifro.org/dcraw/). Windows version was compiled by Sergio Namias (http://www.centrostudiprogressofotografico.it/en/dcraw/). This is a 64bit version. It may not work in Windows 32bit OSs. On Macs 'dcraw' should be installed manually: https://formulae.brew.sh/formula/dcraw
#' @export
procphotos<-function (auto=TRUE,
                      interval = 3,
                      limit=0.8,
                      path,
                      ext=".CR2",
                      method = c("AI","interactive"),
                      model,
                      path.image.model,
                      ext.model=".JPG",
                      colorchecker_y_lim = c(0.25, 0.75),
                      colorchecker_x_lim = c(0.04, 0.11,
                                             0.21, 0.28,
                                             0.38, 0.45,
                                             0.55, 0.62,
                                             0.72, 0.79,
                                             0.89, 0.96),
                      colorchecker_y_size=1.223,
                      colorchecker_x_size=8.738,
                      crop=c(0,0,0,0),
                      Size = NULL,
                      RvaluesR=c(98.35, 65.22, 41.42, 23.17, 9.97, 2.17),
                      RvaluesG=c(97.89, 66.19, 42.45, 23.69, 10.48, 2.22),
                      RvaluesB=c(95.98, 66.87, 43.30, 24.42, 11.13, 2.26),
                      whichRvalues=c(1:6), #which grey values should be used
                      bug.rotate = FALSE,
                      save=FALSE #save images?
) {

  scale.r<-list()
  scale_pixels_cm2<-list()
  scale_pixels_cm<-list()
  Npixels<-list()
  scale_pixels_cm.raw<-list()
  scale_pixels_cm2.raw<-list()
  Npixels.raw<-list()
  pred.r<-list()
  file.name<-list.files(path = path, pattern = ext, ignore.case = TRUE)

  if (method == "AI") {

    file.name.model<-sub(pattern=ext, replacement=ext.model, x=file.name,
                         ignore.case = TRUE)

  }

  old_dir<-getwd()
  setwd(path)
  have.dir<-dir.exists("results")
  if (have.dir==FALSE) {dir.create("results")}

  if (method == "interactive") {

    tags<-dcraw.tags(file.name[[1]])
    img.size<-as.numeric(strsplit(x=tags$`Output size`, split=" x ")[[1]])
    options(fftempdir = tempdir())
    img<-ff::ff(as.vector(read.dcraw(file=file.name[[1]])),
                dim=c(img.size[[2]],img.size[[1]],3,1))

    #whichRvalues<-2:6
    grey<-get_scale_interactive(img=img,
                                crop=crop,
                                N=6)

    asp<-img.size[[2]]/img.size[[1]]

    #talvez o problema do color checker esteja aqui?
    X<-round(grey$x*img.size[[1]],0)
    Y<-round((1-grey$y/asp)*img.size[[2]],0)

    rm(img)
    rm(grey)
  }

  if(auto==TRUE) {

    groups<-find_group(file.name=file.name, interval = interval)

    for (j in 1:length(levels(groups$groups))) {
      gc(reset = TRUE, verbose=FALSE)
      img<-list()
      scale<-list()
      max<-list()
      images<-groups$Filename[groups$groups==levels(groups$groups)[[j]]]

      if (method == "AI") {
        roi.temp<-NULL
      }

      if (method == "interactive") {
        roi.temp<-NULL
        scale_pixels_cm2[[j]]<-NULL
        scale_pixels_cm[[j]]<-NULL

      }

      groups.temp<-groups[groups$groups==levels(groups$groups)[[j]],]

      for (i in 1:length(images)) {
        print(paste("Processing file ",
                    "'",images[[i]],"'",
                    ".",
                    #i,
                    #"/",
                    #nrow(roi),
                    sep="")
        )

        #read image
        #"-w -o 0 -q 0 -4 -T"
        #-w camera white balance
        #-o colour space raw
        #-q interpolation quality
        #-W do not brighten image
        #- 4 16bit
        #-T write tiff
        tags<-dcraw.tags(images[[i]])
        img.size<-as.numeric(strsplit(x=tags$`Output size`, split=" x ")[[1]])
        options(fftempdir = tempdir())
        img[[i]]<-ff::ff(as.vector(read.dcraw(file=images[[i]])),
                         dim=c(img.size[[2]],img.size[[1]],3,1))

        #find scale values

        if (method == "AI") {
          X <- NULL
          Y <- NULL
          Size <- NULL

          #read image jpeg model image
          setwd(path.image.model)
          file.name.model<-sub(pattern=ext.model, replacement=paste(ext), x=images[[i]],
                               ignore.case = TRUE)
          image.model.read<-jpeg::readJPEG(file.path(path.image.model,file.name.model))
          #image.model.read<-jpeg::readJPEG(file.name.model)
          setwd(path)
        }

        if (method == "interactive") {
          model <- NULL
          colorchecker_x_lim <- NULL
          colorchecker_y_lim <- NULL
          colorchecker_y_size <- NULL
          colorchecker_x_size <- NULL

          image.model.read <- NULL
        }


        scale[[i]]<-get_scale_values(img=img[[i]],
                                     method = method,
                                     model=model,
                                     image.model=image.model.read,
                                     colorchecker_x_lim=colorchecker_x_lim,
                                     colorchecker_y_lim=colorchecker_y_lim,
                                     colorchecker_y_size=colorchecker_y_size,
                                     colorchecker_x_size=colorchecker_x_size,
                                     X=X,
                                     Y=Y,
                                     Size = Size,
                                     save = TRUE,
                                     filename=images[[i]])

        modelR<-stats::lm(RvaluesR[whichRvalues]~medianR, data=scale[[i]]$median[whichRvalues,])
        modelG<-stats::lm(RvaluesG[whichRvalues]~medianG, data=scale[[i]]$median[whichRvalues,])
        modelB<-stats::lm(RvaluesB[whichRvalues]~medianB, data=scale[[i]]$median[whichRvalues,])

        modelR.r2<-summary(modelR)$r.square
        modelG.r2<-summary(modelG)$r.square
        modelB.r2<-summary(modelB)$r.square

        if (bug.rotate == TRUE) {

          if (any(c(modelR.r2,modelG.r2,modelB.r2)<0.95)) {
            #try to rotate image to overcome the weird imageJ rotation of some images.

            img[[i]]<-ff::ff(c(as.vector(apply(t(img[[i]][,,1,1]),2,rev)),
                               as.vector(apply(t(img[[i]][,,2,1]),2,rev)),
                               as.vector(apply(t(img[[i]][,,3,1]),2,rev))),
                             dim=list(ncol(img[[i]][,,1,1]),
                                      nrow(img[[i]][,,1,1]),
                                      3,1))

            scale[[i]]<-get_scale_values(img=img[[i]],
                                         method = method,
                                         model=model,
                                         image.model=image.model.read,
                                         colorchecker_x_lim=colorchecker_y_lim,
                                         colorchecker_y_lim=colorchecker_y_lim,
                                         colorchecker_y_size=colorchecker_y_size,
                                         colorchecker_x_size=colorchecker_x_size,
                                         X=X,
                                         Y=Y,
                                         Size = Size,
                                         save = TRUE,
                                         filename=images[[i]])

            modelR<-stats::lm(RvaluesR[whichRvalues]~medianR, data=scale[[i]]$median[whichRvalues,])
            modelG<-stats::lm(RvaluesG[whichRvalues]~medianG, data=scale[[i]]$median[whichRvalues,])
            modelB<-stats::lm(RvaluesB[whichRvalues]~medianB, data=scale[[i]]$median[whichRvalues,])

          }

        }

        max[[i]]<-scale[[i]]$median[whichRvalues[[1]], ]/(256^2-1)

      }

      max.mean<-sapply(X=max, FUN=function(x) mean(as.numeric(x)))

      max.TRUE<-lapply(X=max, FUN=function(x) x<=limit) #quem passa o limite?
      max.TRUE<-sapply(max.TRUE, FUN=function(x) any(x==FALSE)) #quem passa o limite todos os canais

      #selecionar o maior valor que não passa o limite
      chosen<-c(1:length(max.mean))[max.TRUE==FALSE][order(max.mean[max.TRUE==FALSE], decreasing = TRUE)[[1]]]

      #exif<-read_exif(path=paste(file.name[[i]]),
      #                tags=c("ExposureTime", "BracketValue",
      #                       "ShootingMode", "FileModifyDate"))
      if(save==TRUE) {

        filename<-paste(images[[chosen]],
                        "Shutter", groups.temp$Shutter[[chosen]],
                        "max",round(max.mean[[chosen]],2),sep="_")
        filename<-gsub(x=filename, pattern=" ", replacement="_")
        filename<-gsub(x=filename, pattern="/", replacement="_")

        pred<-predict_reflect(scale=scale[[chosen]], #scale data from function get_scale_values
                              img=img[[chosen]], #A tiff image generated by dcraw
                              RvaluesR=RvaluesR,
                              RvaluesG=RvaluesG,
                              RvaluesB=RvaluesB,
                              whichRvalues=whichRvalues,
                              return.image = FALSE,
                              save=save,
                              file.name=file.path("results",filename)
        )
      }

      modelR<-stats::lm(RvaluesR[whichRvalues]~medianR, data=scale[[chosen]]$median[whichRvalues,])
      modelG<-stats::lm(RvaluesG[whichRvalues]~medianG, data=scale[[chosen]]$median[whichRvalues,])
      modelB<-stats::lm(RvaluesB[whichRvalues]~medianB, data=scale[[chosen]]$median[whichRvalues,])

      models<-list(modelR=list(coefficients=modelR$coefficients,
                               model=modelR$model,
                               R2=summary(modelR)$r.squared),
                   modelG=list(coefficients=modelG$coefficients,
                               model=modelG$model,
                               R2=summary(modelG)$r.squared),
                   modelB=list(coefficients=modelB$coefficients,
                               model=modelB$model,
                               R2=summary(modelB)$r.squared))

      scale.r[[j]]<-models
      names(scale.r)[[j]]<-paste(images[[chosen]])
      #names(pred.r)[[j]]<-paste(images[[chosen]])
      rm(img)
      rm(scale)

      scale_pixels_cm2[[j]] <- scale[[chosen]]$scale_pixels_cm2
      scale_pixels_cm[[j]] <- scale[[chosen]]$scale_pixels_cm
      Npixels[[j]] <- scale[[chosen]]$Npixels

      names(scale_pixels_cm2)[[j]]<-paste(images[[chosen]])
      names(scale_pixels_cm)[[j]]<-paste(images[[chosen]])
      names(Npixels)[[j]]<-paste(images[[chosen]])

      scale_pixels_cm2.raw[[j]] <- scale[[chosen]]$scale_pixels_cm2.raw
      scale_pixels_cm.raw[[j]] <- scale[[chosen]]$scale_pixels_cm.raw
      Npixels.raw[[j]] <- scale[[chosen]]$Npixels.raw

      names(scale_pixels_cm2.raw)[[j]]<-paste(images[[chosen]])
      names(scale_pixels_cm.raw)[[j]]<-paste(images[[chosen]])
      names(Npixels.raw)[[j]]<-paste(images[[chosen]])


      results.temp<-list(scale=scale.r,
                         method = method,
                         scale_pixels_cm2 = scale_pixels_cm2,
                         scale_pixels_cm = scale_pixels_cm,
                         Npixels = Npixels,
                         scale_pixels_cm.raw = scale_pixels_cm.raw,
                         scale_pixels_cm2.raw = scale_pixels_cm2.raw,
                         Npixels.raw = Npixels.raw,
                         X = X,
                         Y = Y,
                         Size = Size
      )
      if (j>1) {unlink(file.path("results", result.temp.name))}
      result.temp.name<-paste(names(scale.r)[[1]],"-", names(scale.r)[[j]], "results.temp.rds", sep="")
      saveRDS(results.temp, file = file.path("results", result.temp.name))

    }
  }

  if(auto==FALSE) {

    for (i in 1:length(file.name)) {
      gc(reset = TRUE, verbose=FALSE)
      print(paste("Processing file ",
                  "'",file.name[[i]],"'",
                  ". ",
                  i,
                  "/",
                  length(file.name),
                  sep="")
      )

      #read image
      tags<-dcraw.tags(file.name[[i]])
      img.size<-as.numeric(strsplit(x=tags$`Output size`, split=" x ")[[1]])
      options(fftempdir = tempdir())
      img<-ff::ff(as.vector(read.dcraw(file=file.name[[i]])),
                  dim=c(img.size[[2]],img.size[[1]],3,1))

      #find scale values
      if (method == "AI") {
        X <- NULL
        Y <- NULL
        Size <- NULL

        #read image jpeg model image
        setwd(path.image.model)
        image.model.read<-jpeg::readJPEG(file.path(path.image.model,file.name.model[[i]]))
        #image.model.read<-jpeg::readJPEG(file.name.model[[i]])
        #str(image.model.read)
        setwd(path)

      }

      if (method == "interactive") {
        model <- NULL
        colorchecker_x_lim <- NULL
        colorchecker_y_lim <- NULL
        colorchecker_y_size <- NULL
        colorchecker_x_size <- NULL
        image.model.read <- NULL
      }

      scale<-get_scale_values(img=img,
                              method=method,
                              model=model,
                              image.model=image.model.read,
                              colorchecker_x_lim=colorchecker_x_lim,
                              colorchecker_y_lim=colorchecker_y_lim,
                              colorchecker_y_size=colorchecker_y_size,
                              colorchecker_x_size=colorchecker_x_size,
                              X=X,
                              Y=Y,
                              Size = Size,
                              save = TRUE,
                              filename=file.name[[i]])

      modelR<-stats::lm(RvaluesR[whichRvalues]~medianR, data=scale$median[whichRvalues,])
      modelG<-stats::lm(RvaluesG[whichRvalues]~medianG, data=scale$median[whichRvalues,])
      modelB<-stats::lm(RvaluesB[whichRvalues]~medianB, data=scale$median[whichRvalues,])

      modelR.r2<-summary(modelR)$r.square
      modelG.r2<-summary(modelG)$r.square
      modelB.r2<-summary(modelB)$r.square

      if (bug.rotate == TRUE) {

        if (any(c(modelR.r2,modelG.r2,modelB.r2)<0.95)) {
          #try to rotate image to overcome the weird imageJ rotation of some images.

          img<-ff::ff(c(as.vector(apply(t(img[,,1,1]),2,rev)),
                        as.vector(apply(t(img[,,2,1]),2,rev)),
                        as.vector(apply(t(img[,,3,1]),2,rev))),
                      dim=list(ncol(img[,,1,1]),
                               nrow(img[,,1,1]),
                               3,1))

          scale<-get_scale_values(img=img,
                                  method = method,
                                  model=model,
                                  image.model=image.model.read,
                                  colorchecker_x_lim=colorchecker_x_lim,
                                  colorchecker_y_lim=colorchecker_y_lim,
                                  colorchecker_y_size=colorchecker_y_size,
                                  colorchecker_x_size=colorchecker_x_size,
                                  X=X,
                                  Y=Y,
                                  Size = Size,
                                  save = TRUE,
                                  filename=file.name[[i]])

          modelR<-stats::lm(RvaluesR[whichRvalues]~medianR, data=scale$median[whichRvalues,])
          modelG<-stats::lm(RvaluesG[whichRvalues]~medianG, data=scale$median[whichRvalues,])
          modelB<-stats::lm(RvaluesB[whichRvalues]~medianB, data=scale$median[whichRvalues,])


        }

      }

      max<-round(rowMeans(scale$median)[[ whichRvalues[[1]] ]]/255^2,2)


      if(save==TRUE) {

        exif<-dcraw.tags(file.name[[i]])

        filename<-paste(file.name[[i]],
                        "Timestamp", exif$Timestamp,
                        "Shutter",exif$Shutter,
                        #"exp_prog",exif$ExposureProgram,
                        #"sht_mode",exif$ShootingMode,
                        "max",max,sep="_")
        filename<-gsub(x=filename, pattern=" ", replacement="_")
        filename<-gsub(x=filename, pattern=":", replacement="_")
        filename<-gsub(x=filename, pattern="/", replacement="_")

        pred<-predict_reflect(scale=scale, #scale data from function get_scale_values
                              img=img,
                              RvaluesR=RvaluesR,
                              RvaluesG=RvaluesG,
                              RvaluesB=RvaluesB,
                              whichRvalues=whichRvalues,
                              return.image = FALSE,
                              save=save,
                              file.name=file.path("results",filename))

      }

      models<-list(modelR=list(coefficients=modelR$coefficients,
                               model=modelR$model,
                               R2=summary(modelR)$r.squared),
                   modelG=list(coefficients=modelG$coefficients,
                               model=modelG$model,
                               R2=summary(modelG)$r.squared),
                   modelB=list(coefficients=modelB$coefficients,
                               model=modelB$model,
                               R2=summary(modelB)$r.squared))


      rm(img)
      scale.r[[i]]<-models
      #pred.r[[i]]<-pred$models
      names(scale.r)[[i]]<-file.name[[i]]

      scale_pixels_cm2[[i]] <- scale$scale_pixels_cm2
      scale_pixels_cm[[i]] <- scale$scale_pixels_cm
      Npixels[[i]] <- scale$Npixels

      names(scale_pixels_cm2)[[i]]<-file.name[[i]]
      names(scale_pixels_cm)[[i]]<-file.name[[i]]
      names(Npixels)[[i]]<-file.name[[i]]

      scale_pixels_cm2.raw[[i]] <- scale$scale_pixels_cm2.raw
      scale_pixels_cm.raw[[i]] <- scale$scale_pixels_cm.raw
      Npixels.raw[[i]] <- scale$Npixels.raw

      names(scale_pixels_cm2.raw)[[i]]<-file.name[[i]]
      names(scale_pixels_cm.raw)[[i]]<-file.name[[i]]
      names(Npixels.raw)[[i]]<-file.name[[i]]


      results.temp<-list(scale=scale.r,
                         method = method,
                         scale_pixels_cm2 = scale_pixels_cm2,
                         scale_pixels_cm = scale_pixels_cm,
                         Npixels=Npixels,
                         scale_pixels_cm2.raw = scale_pixels_cm2.raw,
                         scale_pixels_cm.raw = scale_pixels_cm.raw,
                         Npixels.raw=Npixels.raw,
                         X = X,
                         Y = Y,
                         Size = Size
      )
      if (i>1) {unlink(file.path("results", result.temp.name))}
      result.temp.name<-paste(names(scale.r)[[1]],"-", names(scale.r)[[i]], "results.temp.rds", sep="")
      saveRDS(results.temp, file = file.path("results", result.temp.name))


    }
  }

  results<-list(scale=scale.r,
                method = method,
                scale_pixels_cm2 = scale_pixels_cm2,
                scale_pixels_cm = scale_pixels_cm,
                Npixels=Npixels,
                scale_pixels_cm2.raw = scale_pixels_cm2.raw,
                scale_pixels_cm.raw = scale_pixels_cm.raw,
                Npixels.raw=Npixels.raw,
                X = X,
                Y = Y,
                Size = Size
  )
  saveRDS(results, file = file.path("results", paste(names(scale.r)[[1]],"-", names(scale.r)[[length(names(scale.r))]], "_results_converted_photos.rds", sep="")))
  unlink(file.path("results", result.temp.name))
  class(results)<-"procphotos"
  return(results)
  setwd(old_dir)

}


#Function to visualize all scales to verify its OK.
#' Verify conversion.
#'
#' Plot to verify conversion from procphotos function.
#'
#' @param procphotos Results from procphotos function
#' @param scales Path to scales JPG images. Usually 'colorchecker' directory.
#' @return A plot with scale image and regression data of each photo.
#' @export
plot.procphotos <-function(procphotos, scales="colorchecker") {
  #procphotos=ttt
  BestN<-2*length(procphotos$scale)
  pages<-ceiling(BestN/6)
  for (k in 1:pages) {
    if (k<pages) {
      j<-(3*(k-1)+3)
    }
    if (k==pages) {
      j<-length(procphotos$scale)
    }
    graphics::par(mfrow=c(3,2))
    for (i in (3*(k-1)+1):j) {
      scale.file<-dir(scales)[grep(pattern = names(procphotos$scale)[[i]], x=dir(scales))]
      terra::image(terra::rast(jpeg::readJPEG(file.path(scales,scale.file))),
                    col = gray.colors(n=255))
      graphics::par(mar=c(4,4,4,4))
            plot(procphotos$scale[[i]]$modelR$model[,1]~procphotos$scale[[i]]$modelR$model[,2],
         col="red", pch=19, ylab="R%",xlab="Pixel value",
         ylim=c(0,100),
         xlim=c(min(c(min(procphotos$scale[[i]]$modelR$model[,2]),
                      min(procphotos$scale[[i]]$modelG$model[,2]),
                      min(procphotos$scale[[i]]$modelB$model[,2]))
         ),
         max(c(max(procphotos$scale[[i]]$modelR$model[,2]),
               max(procphotos$scale[[i]]$modelG$model[,2]),
               max(procphotos$scale[[i]]$modelB$model[,2]))
         )
         )
    )
    graphics::points(procphotos$scale[[i]]$modelG$model[,1]~procphotos$scale[[i]]$modelG$model[,2],
           col="green", pch=19)
    graphics::points(procphotos$scale[[i]]$modelB$model[,1]~procphotos$scale[[i]]$modelB$model[,2],
           col="blue", pch=19)
    graphics::abline(procphotos$scale[[i]]$modelR, col="red")
    graphics::abline(procphotos$scale[[i]]$modelG, col="green")
    graphics::abline(procphotos$scale[[i]]$modelB, col="blue")
    Rsquare<-paste("R=",round(procphotos$scale[[i]]$modelR$R2,4),"; ",
                   "G=",round(procphotos$scale[[i]]$modelG$R2,4),"; ",
                   "B=",round(procphotos$scale[[i]]$modelB$R2,4),"; ",
                   sep="")
    graphics::text(x=min(procphotos$scale[[i]]$modelG$model[,2]),
                   y=max(procphotos$scale[[i]]$modelG$model[,1]),
                   labels=Rsquare,cex=0.8,adj=0)
    }
    if(k<pages) {
      utils::askYesNo("Show next page?")
    }
  }
}


#Function to go photo by photo select the animal and extract values and save image.
#1. Load photo 1.
#Project it as a sqrt so that it is visible
#Ask user to type ID
#Ask user to select area and the give a name to it.
#User may select more than one area.
#Create a data frame with original photo name, tif photo name, median R, G, B values
#Create a photo from selection with name that contains item ID and original photo names

#plot image and get pixel values
#plot image and get pixel values
#plot image and get pixel values


#https://www.r-spatial.org/r/2017/01/30/mapedit_intro.html
#https://github.com/r-spatial/mapedit/issues/83
#' Interactively get photo data
#'
#' Interactively get data from a converted photo and associate it with item type, item name and reflectance file.
#'
#' @param method Get data from a converted tif file ('file') or process RAW photo on the fly ('pred')
#' @param scale Object from the procphotos functions. Used when method='pred'.
#' @param path Path to access converted photos
#' @param path.spec Path to access reflectance files
#' @param files Vector of file names to analyze. When method='pred', use names(scale$scale) to get only the files selected by the procphotos functions.
#' @param associate.spec Logical. Should photos be associated with spec files.
#' @param spec.files Vector of spec names to associate with photos
#' @param order Order files by name?
#' @param factor factor to reduce image size
#' @param crop crop percentage to reduce image size
#' @param item.location A vector of item locations to be selected by user.
#' @param item.types A vector of item types to be selected by user.
#' @return A data frame in each lines represent data of one extracted patch.
#'  One image of each patch is also saved. Results and images are saved in a 'results' folder.
#' @import raster
#' @import mapedit
#' @import shiny
#' @import leaflet.extras
#' @import miniUI
#' @import leafem
#' @import leaflet
#' @importFrom mapview viewRGB
#' @export
getPhotoData <- function (method=c("file","pred"),
                          scale=NULL,
                          path=getwd(),
                          path.spec=getwd(),
                          files=list.files(path = path, pattern = ".tif", ignore.case = TRUE),
                          associate.spec=TRUE,
                          spec.files=list.files(path = path.spec, pattern = ".txt", ignore.case = TRUE),
                          order=TRUE,
                          factor=10,
                          crop=0,
                          item.location=c("Mata A", "Mata B",
                                       "Mata C","Cerrado A",
                                       "Cerrado B","Cerrado C"),
                          item.types=c("folha cima", "folha baixo",
                                       "folha outro","casca",
                                       "casca liquen","graminea verde",
                                       "graminea seca","serrapilheira",
                                       "animal dorso", "animal ventre",
                                       "animal lateral")

                          ) {

  old.path<-getwd()
  setwd(path)
  have.dir<-dir.exists("results")
  if (have.dir==FALSE) {dir.create("results")}

  #if (method=="pred") {
  #  files<-names(scale$scale)
  #}

  if (order==TRUE) {
    files<-files[order(files)] #by order
  }

  if(associate.spec==TRUE) {
      spec.files<-spec.files[order(spec.files)]
  }

  data.frame.final<-data.frame(image=NULL,
                               item.image=NULL,
                               item.location=NULL,
                               item.type=NULL,
                               item=NULL,
                               specfile=NULL,
                               scale_pixels_cm2.model.image=NULL,
                               scale_pixels_cm.model.image=NULL,
                               item.N.pixels.model.image=NULL,
                               item.N.pixels.raw.image=NULL,
                               scale_pixels_cm2.raw.image=NULL,
                               scale_pixels_cm.raw.image=NULL,
                               item.area_cm2=NULL,
                               mean.L=NULL,
                               median.L=NULL,
                               sd.L=NULL,
                               mad.L=NULL,
                               medianR=NULL,
                               medianG=NULL,
                               medianB=NULL,
                               meanR=NULL,
                               meanG=NULL,
                               meanB=NULL,
                               kernelR=NULL,
                               kernelG=NULL,
                               kernelB=NULL,
                               sdR=NULL,
                               sdG=NULL,
                               sdB=NULL,
                               madR=NULL,
                               madG=NULL,
                               madB=NULL,
                               X=NULL,
                               Y=NULL)


  for (k in 1:length(files)) {

    if (method == "pred") {

      modelR<-stats::lm(scale$scale[[ files[[k]] ]]$modelR$model[,1]~medianR, data=scale$scale[[ files[[k]] ]]$modelR$model)
      modelG<-stats::lm(scale$scale[[ files[[k]] ]]$modelG$model[,1]~medianG, data=scale$scale[[ files[[k]] ]]$modelG$model)
      modelB<-stats::lm(scale$scale[[ files[[k]] ]]$modelB$model[,1]~medianB, data=scale$scale[[ files[[k]] ]]$modelB$model)

      tags<-dcraw.tags(files[[k]])
      img.size<-as.numeric(strsplit(x=tags$`Output size`, split=" x ")[[1]])
      options(fftempdir = tempdir())
      img.temp<-ff::ff(as.vector(read.dcraw(file=files[[k]])),
                       dim=c(img.size[[2]],img.size[[1]],3,1))


      img<-ff::ff(0, dim = c(attr(attr(img.temp, "virtual"), "Dim")[[1]],
                             attr(attr(img.temp, "virtual"), "Dim")[[2]],
                             1,3))

      img[,,1,1]<-predict(object=modelR, newdata=data.frame(medianR=as.vector(img.temp[,,1,1])))
      img[,,1,2]<-predict(object=modelG, newdata=data.frame(medianG=as.vector(img.temp[,,2,1])))
      img[,,1,3]<-predict(object=modelB, newdata=data.frame(medianB=as.vector(img.temp[,,3,1])))
      rm(img.temp)
    }


    if (method == "file") {

      #img<-ijtiff::read_tif(paste(files[[k]]))
      #uma opção seria fazer esse processo antes para economizar tempo
      img<-ijtiff::read_tif(paste(files[[k]]))

    }

    print(paste("Processing image", files[[k]]))

    Rt<-terra::rast(img[,,,1])
    terra::writeRaster(Rt, f <- tempfile(fileext='.tif'), datatype='INT2U')
    Rsmall<-gdalUtilities::gdalwarp(f, f2 <- tempfile(fileext='.tif'), r='med',
                                    multi=TRUE, tr=terra::res(Rt)*factor)
    Rsmall<-terra::rast(Rsmall)


    Gt<-terra::rast(img[,,,2])
    terra::writeRaster(Gt, f <- tempfile(fileext='.tif'), datatype='INT2U')
    Gsmall<-gdalUtilities::gdalwarp(f, f2 <- tempfile(fileext='.tif'), r='med',
                                    multi=TRUE, tr=terra::res(Gt)*factor)
    Gsmall<-terra::rast(Gsmall)

    Bt<-terra::rast(img[,,,3])
    terra::writeRaster(Bt, f <- tempfile(fileext='.tif'), datatype='INT2U')
    Bsmall<-gdalUtilities::gdalwarp(f, f2 <- tempfile(fileext='.tif'), r='med',
                                    multi=TRUE, tr=terra::res(Bt)*factor)
    Bsmall<-terra::rast(Bsmall)


    r  <- terra::rast(xmin=0, xmax=1,
               ymin=0, ymax=nrow(Rsmall)/ncol(Rsmall),
               ncols=ncol(Rsmall), nrows=nrow(Rsmall))
    r <- terra::setValues(r, as.vector(Rsmall))
    g <- terra::setValues(r, as.vector(Gsmall))
    b <- terra::setValues(r, as.vector(Bsmall))

    #process image for better display
    terra::values(r)[terra::values(r)<0]<-0
    terra::values(r)[terra::values(r)>100]<-100
    terra::values(r)[is.na(terra::values(r))==TRUE]<-0
    terra::values(g)[terra::values(g)<0]<-0
    terra::values(g)[terra::values(g)>100]<-100
    terra::values(g)[is.na(terra::values(g))==TRUE]<-0
    terra::values(b)[terra::values(b)<0]<-0
    terra::values(b)[terra::values(b)>100]<-100
    terra::values(b)[is.na(terra::values(b))==TRUE]<-0
    terra::values(r)<-sqrt(terra::values(r)*(256^2)+1)
    terra::values(g)<-sqrt(terra::values(g)*(256^2)+1)
    terra::values(b)<-sqrt(terra::values(b)*(256^2)+1)


    rm(img)

    R  <- terra::rast(xmin=0, xmax=1,
                ymin=0, ymax=nrow(Rt)/ncol(Rt),
                 ncols=ncol(Rt), nrows=nrow(Rt))
    R <- terra::setValues(R, as.vector(Rt))
    G <- terra::setValues(R, as.vector(Gt))
    B <- terra::setValues(R, as.vector(Bt))

    rm(Rt)
    rm(Gt)
    rm(Bt)

    if (crop!=0) {

      #talvez isso aqui esteja trocado. nrow com ncol.
      crop.area<-terra::ext(R)
      crop.area<-crop.area*(1-crop/100)
      R<-terra::crop(x=R, y=crop.area)
      G<-terra::crop(x=G, y=crop.area)
      B<-terra::crop(x=B, y=crop.area)

      crop.area<-terra::ext(r)
      crop.area<-crop.area*(1-crop/100)
      r<-terra::crop(x=r, y=crop.area)
      g<-terra::crop(x=g, y=crop.area)
      b<-terra::crop(x=b, y=crop.area)
      rm(crop.area)
    }

    small.image<-c(r,g,b)

    gc(verbose = FALSE, reset = TRUE, full = TRUE)

    #only place raster package is needed
    map<-mapview::viewRGB(raster::stack(small.image), r = 1, g = 2, b = 3)

    ask<-"yes"
    while(ask=="yes") {
     data<-NULL
     data<-Argiope::editMap2(map, record=F, editor="leafpm")
     #class(data$finished)

     if(is.null(data$finished)==FALSE) {

     print("Storing data...")

     intR<-terra::crop(x=R, y=data$finished)
     intR<-terra::mask(x=intR, mask=data$finished)

     intG<-terra::crop(x=G, y=data$finished)
     intG<-terra::mask(x=intG, mask=data$finished)

     intB<-terra::crop(x=B, y=data$finished)
     intB<-terra::mask(x=intB, mask=data$finished)

     item.location.select<-tcltk::tk_select.list(choices=item.location,
                                           preselect = NULL, multiple = FALSE,
                                           title = "Select item location:")

     item.name.type<-tcltk::tk_select.list(choices=item.types,
                                    preselect = NULL, multiple = FALSE,
                                    title = "Select item type:")

     item.name <- Argiope::item.name.fun()


     #then save file
      new.image<-array(0, dim = c(nrow(intR), ncol(intR), 3),
                     dimnames = list(NULL,NULL,c("red","green","blue")))

      new.image[,,1]<-terra::as.array(intR)
      new.image[,,2]<-terra::as.array(intG)
      new.image[,,3]<-terra::as.array(intB)

      #terra::plotRGB(terra::rast(new.image), r = 1, g = 2, b = 3, scale=100)

      new.image.name<-paste("results/",paste(files[[k]],item.location.select,item.name.type,item.name,sep="_"),sep="")
      ijtiff::write_tif(
              img=new.image,
              path=paste(new.image.name,".tiff", sep=""),
              bits_per_sample = "auto",
              compression = "none",
              overwrite = TRUE, msg = TRUE)

      if(associate.spec==TRUE) {
#        spec.file.name<-select.list(choices=spec.files, preselect = NULL, multiple = FALSE,
#                    title = "Select spec file:", graphics = TRUE)
        print("Select specfile name from list...")
        spec.file.name<-tcltk::tk_select.list(choices=spec.files, preselect = NULL, multiple = FALSE,
                      title = "Select specfile:")
      }

      if(associate.spec==FALSE) {
        spec.file.name<-NA
      }

      Rnew<-new.image[,,1]
      Gnew<-new.image[,,2]
      Bnew<-new.image[,,3]
      Rnew<-Rnew[is.na(Rnew)==FALSE]
      Gnew<-Gnew[is.na(Gnew)==FALSE]
      Bnew<-Bnew[is.na(Bnew)==FALSE]

      kRGB<-c(NA,NA,NA)#find.multimax(cbind(Rnew,Gnew,Bnew))

      L<-(Rnew+Gnew+Bnew)/3

      scale_pixels_cm2<-scale$scale_pixels_cm2[[ files[[k]] ]]
      scale_pixels_cm<-scale$scale_pixels_cm[[ files[[k]] ]]
      scale_pixels_cm2.raw<-scale$scale_pixels_cm2.raw[[ files[[k]] ]]
      scale_pixels_cm.raw<-scale$scale_pixels_cm.raw[[ files[[k]] ]]

      #number of pixels in the object
      #pixels<-sum(new.image[,,1], na.rm = TRUE)

      item.N.pixels.raw.image<-length(as.vector(new.image[,,1])[is.na(as.vector(new.image[,,1]))==FALSE])
      item.area_cm2<-item.N.pixels.raw.image/scale_pixels_cm2.raw

      data.frame.temp<-data.frame(image=files[[k]],
                                  item.image=paste(files[[k]],item.name,".tif",sep="_"),
                                  item.location=item.location.select,
                                  item.type=item.name.type,
                                  item=item.name,
                                  specfile=spec.file.name,
                                  scale_pixels_cm2.model.image=scale_pixels_cm2,
                                  scale_pixels_cm.model.image=scale_pixels_cm,
                                  item.N.pixels.model.image=NA,
                                  item.N.pixels.raw.image=item.N.pixels.raw.image,
                                  scale_pixels_cm2.raw.image=scale_pixels_cm2.raw,
                                  scale_pixels_cm.raw.image=scale_pixels_cm.raw,
                                  item.area_cm2=item.area_cm2,
                                  mean.L=mean(L),
                                  median.L=median(L),
                                  sd.L=sd(L),
                                  mad.L=mad(L),
                                  medianR=stats::median(as.vector(new.image[,,1]),na.rm = TRUE),
                                  medianG=stats::median(as.vector(new.image[,,2]),na.rm = TRUE),
                                  medianB=stats::median(as.vector(new.image[,,3]),na.rm = TRUE),
                                  meanR=mean(as.vector(new.image[,,1]),na.rm = TRUE),
                                  meanG=mean(as.vector(new.image[,,2]),na.rm = TRUE),
                                  meanB=mean(as.vector(new.image[,,3]),na.rm = TRUE),
                                  kernelR=kRGB[[1]],
                                  kernelG=kRGB[[2]],
                                  kernelB=kRGB[[3]],
                                  sdR=stats::sd(as.vector(new.image[,,1]),na.rm = TRUE),
                                  sdG=stats::sd(as.vector(new.image[,,2]),na.rm = TRUE),
                                  sdB=stats::sd(as.vector(new.image[,,3]),na.rm = TRUE),
                                  madR=stats::mad(as.vector(new.image[,,1]),na.rm = TRUE),
                                  madG=stats::mad(as.vector(new.image[,,2]),na.rm = TRUE),
                                  madB=stats::mad(as.vector(new.image[,,3]),na.rm = TRUE),
                                  X=paste0(data$finished$geometry[[1]][[1]][,1], collapse=","),
                                  Y=paste0(data$finished$geometry[[1]][[1]][,2], collapse=",")
                                  )
      data.frame.final<-rbind(data.frame.final,data.frame.temp)

      if (k>1) {unlink(file.path("results", results.temp.name))}
      results.temp.name<-paste(files[[1]],"-",files[[k]],"resultsTEMP.csv",sep="")
      utils::write.csv(x=data.frame.final, file=file.path("results",results.temp.name), row.names = F)

     }

    ask<-tcltk::tk_messageBox(type = c("yesnocancel"),
                   message="Get more data on the same photo?", caption = "", default = "")

    }
  }

  results.name<-paste(files[[1]],"-",files[[k]],"collected_data.csv",sep="")

  is.there.a.file <- results.name%in%list.files("results")

  if (is.there.a.file==TRUE) {
    ask<-tk_messageBox(type = c("yesnocancel"),
                       message="There is already a results file. Append results?", caption = "", default = "no")
    if(ask=="yes") {
      old_result<-utils::read.csv(file= file.path("results", results.name))
      data.frame.final<-rbind(old_result,data.frame.final)
      utils::write.csv(x=data.frame.final, file= file.path("results", results.name), row.names = F)
      print(paste("Data saved to", results.name))

    }

    if(ask=="no") {
      utils::write.csv(x=data.frame.final, file=file.path("results", results.name), row.names = F)
      print(paste("Data saved to", results.name))

    }

    if(ask=="cancel") {
      return(data.frame.final)
    }

    if(is.null(ask)==TRUE) {
      return(data.frame.final)
    }

  }

  if (is.there.a.file==FALSE) {
    utils::write.csv(x=data.frame.final, file=file.path("results", results.name), row.names = F)
    print(paste("Data saved to", results.name))
  }

  unlink(file.path("results", results.temp.name))
  setwd(old.path)
  return(data.frame.final)
}

#Funcao para encontrar funcao para estimar espectro, ou
#para estimar um espectro com base em uma funcao conhecida G
#' Wiener training
#'
#' Find the G matrix based on a training RGB and reflectance data.
#'
#' @param R A data.frame of training reflactance curves. Do not include a column with wavelength values.
#' @param tRGB A matrix with R, G, and B values (columns) associated with the reflectance values
#' @return The G matrix
#' @export
Wiener.training<-function(R=NULL, #curvas de reflectancia (sem o nm)
                 tRGB=NULL) { #funcao de estimar curvas
  r<-as.matrix(R)
  v<-t(as.matrix(tRGB))
  G<-(r%*%t(v))%*%solve(v%*%t(v))
  print("G estimated from the training data")
  r<-G
  return(r)
}

#Funcao para encontrar funcao para estimar espectro, ou
#para estimar um espectro com base em uma funcao conhecida G
# Wiener prediction
#
# Find predicted reflectance spectra based on a G function.
#
# @param RGB A matrix with R, G, and B values (columns) to be used to estimate reflectance values
# @param G A Wiener G function to estimate reflectance curves based on RGB.
# @return Matrix of predicted reflectance values.
# @export
#Wiener.predict<-function(RGB=NULL, #valores de RGB para estimar curva
#                         G=NULL) { #funcao de estimar curvas
#  r_hat<-NULL
#  if(is.null(RGB)==FALSE&is.null(G)==FALSE) {
#
#    new_v<-t(as.matrix(RGB))
#    r_hat<-matrix(ncol=nrow(RGB),nrow=nrow(G))
#    for (i in 1:nrow(RGB)) {
#      r_hat[,i]<-G%*%new_v[,i]
#    }
#  }
#  r<-r_hat
#  return(r)
#}



#Funcao para plotar uma imagem e ter as curvas de reflectancia
#preditas. Precisa ajustar o argumento img para ler tif ou raster
# Image Wiener predict.
#
# Funcao para plotar uma imagem e ter as curvas de reflectancia.
#  Precisa ajustar o argumento img para ler tif ou raster. Ainda não funciona direito.
#
# @param img Image
# @param G A Wiener G function to estimate reflectance curves based on RGB.
# @return Interactive plot.
#image.spec.predict<-function(img, G) {
#
#  graphics::par(mfrow=c(1,2))
#  #raster::image(image$)
#  terra::plotRGB(convert.image.mspec$image.sqrt)
#  print("Click on the image to select points, then press 'esc' to show predicted reflectance curves")
#  data<-click(x=convert.image.mspec$image.c,
#              n=Inf, id=TRUE,
#              cell=T, type="n", show=TRUE)
#
#  #WIENER TRANSFORMATION
#  RGBdata<-as.matrix(data[,2:4])
#  Wiener.data<-Wiener.predict(RGB=RGBdata,G=G)
#  nm<-300:700
#  plot(Wiener.data[,1]~nm,
#       ylim=c(min(Wiener.data[,]),max(Wiener.data[,])),
#       type="l")
#  for (i in 2:ncol(Wiener.data)) {
#    lines(Wiener.data[,i]~nm)
#  }
#  text(label=1:ncol(Wiener.data),
#       x=700,
#       y=Wiener.data$r_hat[401,])
#}

#find group of photos by interval time in seconds
#' Read RAW photos
#'
#' Get camera data using dcraw.
#'
#' @param file Raw file name.
#' @param args arguments to be passed to dcraw.
#' @return An array with RGB values.
#' @details This function uses dcraw by Dave Coffin (https://www.dechifro.org/dcraw/). Windows version was compiled by Sergio Namias (http://www.centrostudiprogressofotografico.it/en/dcraw/). This is a 64bit version. It may not work in Windows 32bit OSs. Code was based on read.raw function in package Adimpro. To install dcraw on Macs see https://r-spatial.org/r/2023/05/15/evolution4.html. Currently it works only with tiff generated files (i.e. args must include -T dcraw parameter).
#' @export
read.dcraw<-function(file, args="-W -o 0 -q 0 -4 -T") {
  #print("To install dcraw on Mac see https://www.dechifro.org/dcraw/")
  old<-getwd()

  Argiope.path<-file.path(find.package("Argiope"),"dcraw")

  #

  #file<-"IMG_1826.CR2"
  ext<-strsplit(file, "\\.")[[1]][[2]]

  tmpfile0 <- tempfile("raw")
  tmpfile <- file.path(paste(c(tmpfile0, ext), collapse = "."))

  file.copy(file, tmpfile)

  #system2(command=Argiope.path, args=paste(args, tmpfile))
  setwd(find.package("Argiope"))
  system2(command="dcraw", args=paste(args, tmpfile))

  #currently it works for tiff files only
  filenamep <- file.path(paste(tmpfile0, ".tiff", sep = ""))

  img<-ijtiff::read_tif(filenamep)

  unlink(tmpfile, recursive = FALSE, force = TRUE)
  unlink(filenamep, recursive = FALSE, force = TRUE)

  setwd(old)

  return(img)

}
